class InMemoryCheckpointer:
  """A Checkpointer reliant on an in-memory global dictionary."""

  def __init__(self, config, mode: str):
    self._max_checkpoints_to_keep = config.max_checkpoints_to_keep
    del mode

  def _override_or_insert(self, current_state, snapshot):
    """Update the current state based on a snapshot."""
    for sk, sv in snapshot.items():
      # Duck-typing for "is this a Jaxline Experiment class?".
      if (sk in current_state
          and hasattr(current_state[sk], "CHECKPOINT_ATTRS")
              and hasattr(current_state[sk], "NON_BROADCAST_CHECKPOINT_ATTRS")):
        for kk in sv.CHECKPOINT_ATTRS:
          setattr(current_state[sk], kk, getattr(sv, kk))
        for kk in sv.NON_BROADCAST_CHECKPOINT_ATTRS:
          setattr(
              current_state[sk], kk,
              jax.tree_map(copy.copy, getattr(sv, kk)))
      else:
        current_state[sk] = sv

  def get_experiment_state(self, ckpt_series: str):
    """Returns the experiment state for a given checkpoint series."""
    if ckpt_series not in GLOBAL_CHECKPOINT_DICT:
      active = threading.local()
      new_series = CheckpointNT(active, [])
      GLOBAL_CHECKPOINT_DICT[ckpt_series] = new_series
    if not hasattr(GLOBAL_CHECKPOINT_DICT[ckpt_series].active, "state"):
      GLOBAL_CHECKPOINT_DICT[ckpt_series].active.state = (
          config_dict.ConfigDict())
    return GLOBAL_CHECKPOINT_DICT[ckpt_series].active.state

  def save(self, ckpt_series: str) -> None:
    """Saves the checkpoint."""
    series = GLOBAL_CHECKPOINT_DICT[ckpt_series]
    active_state = self.get_experiment_state(ckpt_series)
    id_ = 0 if not series.history else series.history[-1].id + 1
    snapshot = copy.copy(active_state) 
    # Hack to avoid that the state is not available at a later point in time
    snapshot.experiment_module = copy.copy(snapshot.experiment_module)
    snapshot.experiment_module._params = jax.tree_map(
      lambda x: x.copy(), snapshot.experiment_module._params)
    series.history.append(SnapshotNT(id_, snapshot))
    if len(series.history) > self._max_checkpoints_to_keep:
      GLOBAL_CHECKPOINT_DICT[ckpt_series] = series._replace(
          history=series.history[-self._max_checkpoints_to_keep:])
    logging.info("Saved checkpoint %s with id %s.", ckpt_series, id_)